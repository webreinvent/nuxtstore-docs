---
title: JsonSerializable
description: Managing Json data parsing in the App using json_serializable
---

## What is the core problem?

In any application that communicates with a server via APIs, a critical task is converting data between JSON strings and structured Dart objects. This process, known as serialization (object to JSON) and deserialization (JSON to object), must be reliable, efficient, and maintainable. We will evaluate the two primary approaches for this in Dart & Flutter.

- Manual Serialization
- Automated Code Generation


## What we want to avoid intentionally
- **Runtime Reflection:** Some programming languages use reflection to inspect object structures at runtime and perform serialization automatically. However, dart:mirrors (Dart's reflection library) is disabled in Flutter for release builds to reduce application size and improve performance. Therefore, any solution relying on runtime reflection is not viable for production Flutter apps.

- **Manual Parsing for Complex Models:** While writing parsing logic by hand might seem quick for a simple model with one or two fields, this approach does not scale. As models become nested or more complex, the risk of human error, the maintenance burden, and the amount of boilerplate code grow exponentially.

## Manual Serialization
This approach involves manually writing the logic to map JSON keys to class fields inside ```fromJson``` and ```toJson``` methods for every model.

### Pros
- **No Dependencies:** It requires no external packages or build tools.

- **Simplicity (at first):** For trivial data models, the implementation is straightforward and easy to understand.

### Cons
- **Error-Prone:** It is highly susceptible to runtime errors caused by simple typos in JSON keys or incorrect type casting. These errors are not caught by the compiler.

- **High Maintenance:** If the API response or the Dart model changes, developers must manually find and update all relevant parsing logic, which is a tedious and risky process.

- **Boilerplate Code:** It leads to a significant amount of repetitive, boilerplate code that clutters the models and adds little business value.

- **Lack of Safety:** There is no compile-time guarantee that the parsing logic correctly matches the model's structure.

## Code Generation (json_serializable)

This approach uses annotations within the model classes to define how they should be serialized. A build tool (build_runner) then reads these annotations and automatically generates all the necessary serialization and deserialization code.


### Pros

- **Type Safety:** The generator creates strongly-typed parsing logic. Mismatches between your model and the generated code result in compile-time errors, not runtime crashes.

- **Maintainability:** The model class itself is the single source of truth. When you update a field, you simply re-run the code generator to update the parsing logic, eliminating manual effort and reducing risk.

- **Eliminates Boilerplate:** It completely removes the need to write and maintain tedious fromJson/toJson implementations.

- **Performance:** The generated code is direct, efficient, and optimized for AOT (Ahead-Of-Time) compilation, resulting in excellent runtime performance.
Robustness: It gracefully handles complex scenarios out-of-the-box, including nested objects, lists, enums, default values, and null safety.


### Cons

- **Initial Setup:** It requires adding dev_dependencies and learning to run the build_runner command.

- **Build Step:** A build step is required to generate or update the code, which adds a minor delay during development.
